<!DOCTYPE html>
<html>

<head>
  <title>播放器</title>
  <link rel="stylesheet" href="./css/index.css">

</head>

<body>
  <div class="app" id="app">
    <div class="list-box">
      <div class="item" v-for="(item, index) in list" :class="{ active: index == listIndex }" @click="listIndex = index">
        {{item.name}}{{index}}
      </div>
    </div>
    <div class="">
      选集<input v-model="num">
    </div>
    <div class="" @click="play">获取</div>
  </div>
  <div id="video-wrapper">

  </div>
  <script src="./js/vue.js"></script>
  <script src="./dist/mux.js"></script>

  <script>
    var app = new Vue({
      el: '#app',
      data: {
        listIndex:0,
        num:1,
        list: [
          {
            name:"1系列",
            url:"https://v.qiexiazai.com/fuckyou-9527/xr163/8000kb/hls/index{{index}}.ts"
          },
          {
            name:"2系列",
            url:"https://v.qiexiazai.com/fuckyou-9527/xr163/8000kb/hls/index{{index}}.ts"
          }
        ]
      },
      method:{
        play(){

        }
      }
    })
    function getData(url) {
      return
      let xhr = new XMLHttpRequest();
      let resStatus = 1
      url = url.replace("{{index}}", urlIndex);
      xhr.onerror = function(e){
        console.log(e,"请求错误")
      }
      xhr.onloadend = function(e){
        
        if(e.lengthComputable == false){
          console.log(e,"下载异常")
          timeOutDeal()
        }
      }
      xhr.open('GET', url);
      // 接收的是 video/mp2t 二进制数据，并且arraybuffer类型方便后续直接处理 
      xhr.responseType = "arraybuffer";
      xhr.send();
      var timer = setTimeout(timeOutDeal,3000)
      
      //超时之后的处理。停止当前请求，重新发起请求。
      function timeOutDeal(){
        clearTimeout(timer)
        if(resStatus == 1){
          console.log("请求超时", resStatus)
        }else{
          console.log("响应超时", resStatus)
        }
        resStatus = 1
        xhr.abort()
        setTimeout(function(){
          xhr.open('GET', url);
          xhr.send();
          timer = setTimeout(timeOutDeal,3000)
        },1000)
      
      }
   
      xhr.onreadystatechange = function () {
        //3开始接收响应体  4响应体接收完成
       
        if(xhr.readyState >= 3){
          clearTimeout(timer)
          //接收响应体的过程中，会多次触发此回调，readyState都是3，如果回调间隔过长，表示接收数据阻塞，这里也设置一个超时。
          //取消请求的时候会有一个 readyState是3的回调，status为0.
          if(xhr.readyState == 3){
            timer = setTimeout(timeOutDeal,5000)
            console.log("开始响应")
            resStatus = 2
          }
          if (xhr.readyState == 4) {
            if (xhr.status == 200) {
              transferFormat(xhr.response);
            } else {
              console.log(xhr.status,'请求结束，结果error')
            }
          }
        }

      }
    }

    var urls = "https://v.qiexiazai.com/fuckyou-9527/xr163/8000kb/hls/index{{index}}.ts";
    var $ = document.querySelector.bind(document);
    var vjsParsed,
      video,
      buffer,
      mediaSource,
      urlIndex = 0 //请求链接序号;
    
    video = document.createElement('video');
    video.controls = true;
    video.addEventListener('error', logevent);

    mediaSource = new MediaSource();

    video.src = URL.createObjectURL(mediaSource);
    $('#video-wrapper').appendChild(video);

    function logevent(event) {
      console.log(event);
    }
   
    mediaSource.addEventListener('sourceopen', function () {
      // MediaSource 实例默认的duration属性为NaN
      mediaSource.duration = 0;
      // 转换后mp4的音频格式 视频格式
      var codecsArray = ["avc1.64001f", "mp4a.40.5"];
      var outputType = "video"
      var combined = false
      // 转换为带音频、视频的mp4
      if (combined) {
        buffer = mediaSource.addSourceBuffer('video/mp4;codecs="' + 'avc1.64001f,mp4a.40.5' + '"');
      } else if (outputType === 'video') {
        // 转换为只含视频的mp4
        buffer = mediaSource.addSourceBuffer('video/mp4;codecs="' + codecsArray[0] + '"');
      } else if (outputType === 'audio') {
        // 转换为只含音频的mp4
        buffer = mediaSource.addSourceBuffer('audio/mp4;codecs="' + (codecsArray[1] || codecsArray[0]) + '"');
      }
      buffer.mode = 'sequence'
      buffer.addEventListener('updatestart', logevent);
      buffer.addEventListener('updateend', function () {
        urlIndex++
        getData(urls)
      });
      buffer.addEventListener('error', logevent);
  
   
      getData(urls)

    });

    function transferFormat(data) {
      // 将源数据从ArrayBuffer格式保存为可操作的Uint8Array格式
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer
      var segment = new Uint8Array(data);
      var combined = false;
      // 接收无音频ts文件，OutputType设置为'video'，带音频ts设置为'combined'
      var outputType = 'video';
      var remuxedSegments = [];
      var remuxedBytesLength = 0;
      var remuxedInitSegment = null;

      // remux选项默认为true，将源数据的音频视频混合为mp4，设为false则不混合
      var transmuxer = new muxjs.mp4.Transmuxer({
        remux: false
      });

      // 监听data事件，开始转换流
      transmuxer.on('data', function (event) {
        console.log(event);
        if (event.type === outputType) {
          remuxedSegments.push(event);
          remuxedBytesLength += event.data.byteLength;
          remuxedInitSegment = event.initSegment;
        }
      });
      // 监听转换完成事件，拼接最后结果并传入MediaSource
      transmuxer.on('done', function () {
        var offset = 0;
        var bytes = new Uint8Array(remuxedInitSegment.byteLength + remuxedBytesLength)
        bytes.set(remuxedInitSegment, offset);
        offset += remuxedInitSegment.byteLength;

        for (var j = 0, i = offset; j < remuxedSegments.length; j++) {
          bytes.set(remuxedSegments[j].data, i);
          i += remuxedSegments[j].byteLength;
        }
        remuxedSegments = [];
        remuxedBytesLength = 0;
        // 解析出转换后的mp4相关信息，与最终转换结果无关
        vjsParsed = muxjs.mp4.tools.inspect(bytes);
        console.log('transmuxed', vjsParsed);

        buffer.appendBuffer(bytes);
      });
      // push方法可能会触发'data'事件，因此要在事件注册完成后调用
      transmuxer.push(segment); // 传入源二进制数据，分割为m2ts包，依次调用上图中的流程
      // flush的调用会直接触发'done'事件，因此要事件注册完成后调用
      transmuxer.flush(); // 将所有数据从缓存区清出来
    }

  </script>
</body>


</html>